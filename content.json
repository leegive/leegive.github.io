{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Spring Cloud Stream 如何处理消息重复消费","text":"问题重现构建消息消费端 创建绑定接口，绑定example-topic输入通道（默认情况下，会绑定到RabbitMQ的同名Exchange或Kafaka的同名Topic）。 12345678interface ExampleBinder { String NAME = \"example-topic\"; @Input(NAME) SubscribableChannel input();} 对上述输入通道创建监听与处理逻辑。 1234567891011@EnableBinding(ExampleBinder.class)public class ExampleReceiver { private static Logger logger = LoggerFactory.getLogger(ExampleReceiver.class); @StreamListener(ExampleBinder.NAME) public void receive(String payload) { logger.info(\"Received: \" + payload); }} 创建应用主类和配置文件 12345678@SpringBootApplicationpublic class ExampleApplication { public static void main(String[] args) { SpringApplication.run(ExampleApplication.class, args); }} 12spring.application.name=stream-consumer-groupserver.port=0 这里设置server.port=0，以方便在本地启动多实例来重现问题。 构建消息生产端比较简单，需要注意的是，使用@Output创建一个同名的输出绑定，这样发出的消息才能被上述启动的实例接收到。具体实现如下： 12345678910111213141516171819202122@RunWith(SpringRunner.class)@EnableBinding(value = {ExampleApplicationTests.ExampleBinder.class})public class ExampleApplicationTests { @Autowired private ExampleBinder exampleBinder; @Test public void exampleBinderTester() { exampleBinder.output().send(MessageBuilder.withPayload(\"Produce a message from : http://blog.didispace.com\").build()); } public interface ExampleBinder { String NAME = \"example-topic\"; @Output(NAME) MessageChannel output(); }} 启动上述测试用例之后，可以发现之前启动的两个实例都收到的消息，并在日志中打印了：Received: Produce a message from : http://blog.didispace.com。消息重复消费的问题成功重现！ 使用消费组解决问题如何解决上述消息重复消费的问题呢？我们只需要在配置文件中增加如下配置即可： 1spring.cloud.stream.bindings.example-topic.group=aaa 当我们指定了某个绑定所指向的消费组之后，往当前主题发送的消息在每个订阅消费组中，只会有一个订阅者接收和消费，从而实现了对消息的负载均衡。只所以之前会出现重复消费的问题，是由于默认情况下，任何订阅都会产生一个匿名消费组，所以每个订阅实例都会有自己的消费组，从而当有消息发送的时候，就形成了广播的模式。 另外，需要注意上述配置中example-topic是在代码中@Output和@Input中传入的名字。","link":"/2018/11/15/Spring-Cloud-Stream-如何处理消息重复消费/"},{"title":"程序设计竞赛-Ants","text":"题目Ants - POJ No. 1852 描述$n$只蚂蚁以每秒1cm的速度在长为$Lcm$的竿子上爬行。当蚂蚁爬到竿子的端点时就会掉落。由于竿子太细，两只蚂蚁相遇时，它们不能交错通过，只能各自反向爬回去。对于每只蚂蚁，我们知道它距离竿子左端的距离$X_i$，但是不知道它当前的朝向。请计算所有蚂蚁落下竿子所需的最短时间和最长时间。 限制条件 $ 1 \\leq L \\leq 10^6 $ $ 1 \\leq n \\leq 10^6 $ $ 0 \\leq x_i \\leq L $ 输入$ L = 10 $$ n = 3 $$ x = {2, 6, 7} $ 输出$ min = 4(左、右、右) $$ max = 8(右、右、右) $ 分析首先很容易想到一个穷竭搜索算法，即枚举所有蚂蚁的初始朝向的组合，这可以利用递归函数实现。 每只蚂蚁的初始朝向都有2种可能，$n$只蚂蚁就是$2 \\times 2 \\times \\cdots \\times 2 = 2^n$种。如果$n$比较小，这个算法还是可行的，但指数函数随着$n$的增长会极烈增长。 穷竭搜索的运行时间也随着剧烈增长。一般把指数阶的运行时间叫做指数时间。指数时间的算法无法处理稍大规模的输入。 接下来，让我们来考虑比穷竭搜素更高效的算法。首先对于最短时间，看起来所有蚂蚁都朝向较近的端点走会比较好。事实上，这种情况下不会发生两只蚂蚁相遇的情况，而且也不可能在比此更短的时间内走到杆子的断点。 接下来，为了思考最长时间的情况，让我们看看蚂蚁相遇时\b会发生什么。 事实上，可以知道两只蚂蚁相遇后，当它们保持原样交错而过继续前进也不会有任何问题。这样看来，可以认为每只蚂蚁都是独立运动的，\b所有要求最长时间，只要求蚂蚁到杆子端点的最大距离就好了。 这样，不论最长时间还是最短时间，都只要对每次蚂蚁检查一次就好了，这是$O(n)$时间的算法。对于限制条件$n \\leq 10^6$，这个算法是够用的，于是问题得解。 答题123456789101112131415161718int l, n;int[] x;public solve() { // 计算最短的时间 int minTime = 0; for (int i = 0; i &lt; n; i++) { minTime = Math.max(minTime, Math.min(x[i], l - x[i])); } // 计算最长的时间 int maxTime = 0; for (int i = 0; i &lt; n; i++) { maxTime = Math.max(maxTime, Math.max(x[i], l - x[i])); } System.out.print(\"%d %d\\n\", minT, maxT);} 这个问题可以说是观察想象力类型问题的经典\b例子。有很多这样的问题，虽然开始不太明白，但相同后，最后的程序却是出乎意料地简单。","link":"/2018/11/18/程序设计竞赛-Ants/"},{"title":"程序设计竞赛-理解何谓程序设计竞赛","text":"顾名思义，程序设计竞赛就是以程序为主题举办的竞赛。世界上有解题竞赛、性能竞赛、创意竞赛等各种各样的程序设计竞赛。下面用题目来描述： 题目抽签 你的朋友建议玩一个游戏：将写有数字的$n$个纸片放入口袋中，你可以从口袋中抽取4次纸片，每次记下纸片上的数字后将其放回口袋中。如果4个数字的和是$m$，就是你赢，否则就是你的朋友赢。你挑战了好几回，结果一次也没有赢过，于是撕破口袋，取出所有纸片，检查自己是否真的有赢的可能性。请你编写一个程序，判断当纸片上所写的数字是$k_1, k_2, \\cdots, k_n$时，是否存在抽取4次和为$m$的方案。如果存在，输出Yes； 否则，输出No。","link":"/2018/11/18/程序设计竞赛-理解何谓程序设计竞赛/"},{"title":"程序设计竞赛-轻松热身","text":"三角形 有n根棍子，棍子$i$长度为$a_i$。想要从中徐阿初3根棍子组成周长尽可能长的三角形。请输出最大的周长，若无法组成三角形则输出0。 限制条件 $ 3 \\leq n \\leq 100 $ $ 1 \\leq a_i \\leq 10^6 $ 样例1输入$ n = 5 $$ a = {2, 3, 4, 5, 10} $ 输出12(选择3、4、5时)样例2输入$ n = 4 $$ a = {4, 5, 10, 20} $ 输出$ 0 (无论怎么选都无法组成三角形) $ 分析选择3根棍子，它们能组成的充分条件为最长棍子的长度 &lt; 其余两根棍子的长度之和 于是我们可以试想这样一种算法：首先用三重循环\b枚举所有的棍子选择方案，再利用上式判断能否组成三角形。如果可以，那么该三角形的周长就是备选答案。 这里用了三重循环，所有复杂度是$O(n^3)$。将$n=100$代入$n^3$得到$10^6$，可知这个复杂度是足够低的。 答题12345678910111213141516171819202122232425262728int n;int[] a;public void solve() { // 备选答案 int ans = 0; // 让 i &lt; j &lt; k, 这样棍子就不会被重复选中了 \bfor(int i = 0; i &lt; n; i++) { for(int j = i + 1; j &lt; n; j++) { for(int k = j + 1; k &lt; n; k++) { // 三角形周长 int len = a[i] + a[j] + a[k]; // 最长的棍子 int ma = max(a[i], max(a[j], a[k])); //其余两棍子长度之和 int rest = len - ma; //\b如果可以组成三角形，就更新备选答案 if(ma &lt; rest) { ans = max(ans, len); } } } } System.out.println(ans);}","link":"/2018/11/18/程序设计竞赛-轻松热身/"}],"tags":[{"name":"Spring Cloud Stream","slug":"Spring-Cloud-Stream","link":"/tags/Spring-Cloud-Stream/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"POJ","slug":"POJ","link":"/tags/POJ/"}],"categories":[{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"算法","slug":"算法","link":"/categories/算法/"}]}